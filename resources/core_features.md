# Основные возможности SQL

> Список терминов: 
[Внутреннее соединение (inner join)](/resources/glossary.md?id=Внутреннее-соединение-inner-join), 
[Левое внешнее соединение (left outer join)](/resources/glossary.md?id=Левое-внешнее-соединение-left-outer-join), 
[Cоединение таблиц (join)](/resources/glossary.md?id=Объединение-таблиц-join), 
[Перекрестное соединение (cross join)](/resources/glossary.md?id=Перекрестное-соединение-cross-join), 
[Полное внешнее соединение (full outer join)](/resources/glossary.md?id=Полное-внешнее-соединение-full-outer-join),
[Соединение (join)](/resources/glossary.md?id=Соединение-join), 
[Условие соединения (join condition)](/resources/glossary.md?id=Условие-соединения-join-condition), 
[Правое внешнее соединение (right outer join)](/resources/glossary.md?id=Правое-внешнее-соединение-right-outer-join), 
[Самосоединение (self join)](/resources/glossary.md?id=Самосоединение-self-join), 

### Поиск строк по шаблону

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/0001d196c4fa39ca0249e18ba1e537f8/))

```sql
select
    personal,
    family
from staff
where personal like '%ya%';
```
```
| personal | family |
|----------|--------|
| Nitya    | Lal    |
```

- `like` это исходное средство сопоставления шаблонов SQL.
- `_` соответствует одному любому символу.
- `%` соответствует нулю или более символам.
- По умолчанию в SQLite `like` нечувствителен к регистру текста (результат `like '%ya%'` идентичен результату `like '%YA%'`). Другие СУБД могут вести себя иначе!
- `glob` поддерживает подстановочные знаки в стиле Unix (`*` вместо `%` и `?` вместо `_`). Не является стандартом SQL (не работает в других СУБД)! 


#### Упражнение

1. Из таблицы `staff` выберите все данные сотрудников чья фамилия начинается с буквы 'K' (английская буква), используя ключевое слово `like`.
2. Перепишите предыдущий запрос, используя ключевое слово `glob`.

([тренажёр sql онлайн](https://sqltest.online/ru/question/sqlite/staff-family-starts-with-k))

## Агрегация

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/d208c0b539b4be11345c3a2e6ed8f9d2/))

```sql
select
    sum(body_mass_g) as total_mass
from penguins;
```
```
| total_mass |
|------------|
| 1437000    |
```

- Агрегация объединяет множество значений для получения одного.
- `sum` — это функция агрегирования (агрегатная функция).  
- `sum(column_name)` - суммирует все значения в колонке `column_name` исключая `null`
- `sum(expression)` - суммирует все результаты выражения `expression` вычисленного для каждой строки (исключая `null`)
- Объединяет соответствующие значения из нескольких строк.
- Существует множество агрегатных функций. Некоторые входят в стандарт SQL, некоторые специфичны для определённых СУБД. 

### Основные агрегатные функции

- `max(имя столбца или выражение)` - максимальное значение столбца или выражения (вычисляемого для каждой строки)
- `min(имя столбца или выражение)` - минимальное значение столбца или выражения (вычисляемого для каждой строки)
- `sum(имя столбца или выражение)` - сумма значений столбца или выражения
- `avg(имя столбца или выражение)` - среднее значение 

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/bcee1003096fc086d60954f2f6ad6a85/))

```sql
select
    max(bill_length_mm) as longest_bill,
    min(flipper_length_mm) as shortest_flipper,
    avg(bill_length_mm) / avg(bill_depth_mm) as weird_ratio
from penguins;
```
```
| longest_bill | shortest_flipper |   weird_ratio    |
|--------------|------------------|------------------|
| 59.6         | 172.0            | 2.56087082530644 |
```
- Все агрегатные функции возвращают одно значение.
- Все агрегатные функции игнорируют `null` значения.
- На самом деле это не должно работать: невозможно вычислить максимальное или среднее значение, если какие-либо значения равны нулю.
- SQL делает полезную вещь вместо правильной

#### Упражнения 

1. Какова средняя масса тела пингвинов весом более 3000 граммов?

### Подсчет строк

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/783908785044a5c9066acf9632e4ccc8/))

```sql
select
    count(*) as count_star,
    count(sex) as count_specific,
    count(distinct sex) as count_distinct
from penguins;
```
```
| count_star | count_specific | count_distinct |
|------------|----------------|----------------|
| 344        | 333            | 2              |
```

- `count(*)` - считает строки.
- `count(column)` - подсчитывает непустые (не `null`) записи в столбце.
- `count(distinct column)` - подсчитывает уникальные непустые (не `null`) записи.

#### Упражнения

1. Сколько разных масс тела содержится в наборе данных по пингвинам?
2. [Найдите количество видов пингвинов и количество островов на которых они обитают](https://sqltest.online/ru/question/sqlite/penguins-islands-quantity).

### Группировка

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/d1a1b06d5abbd587add37331d645b00c/))

```sql
select 
    avg(body_mass_g) as average_mass_g
from penguins
group by sex;
```
```
|  average_mass_g  |
|------------------|
| 4005.55555555556 |
| 3862.27272727273 |
| 4545.68452380952 |
```

- Поместите строки в группы на основе различных комбинаций значений в столбцах, указанных с помощью `group by`
- Затем выполните агрегацию отдельно для каждой группы.
- Но что есть что?


### Поведение неагрегированных столбцов

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/23ec4ad50459f657b5ee0cfe5b3ce0af/))

```sql
select
    sex,
    avg(body_mass_g) as average_mass_g
from penguins
group by sex;
```
```
|  sex   |  average_mass_g  |
|--------|------------------|
| [null] | 4005.55555555556 |
| FEMALE | 3862.27272727273 |
| MALE   | 4545.68452380952 |
```

- Все строки в каждой группе имеют одинаковое значение пола, поэтому агрегировать не нужно.

#### Упражнения

1. [Подсчитайте количество пингвинов каждого вида](https://sqltest.online/ru/question/sqlite/penguins-quantity). 

### Произвольный выбор при агрегировании

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/6b20be9d42a236102d074f219291470b/))

```sql
select
    sex,
    body_mass_g                   
from penguins
group by sex;
```
```
|  sex   | body_mass_g |
|--------|-------------|
| [null] | [null]      |
| FEMALE | 3800.0      |
| MALE   | 3750.0      |
```

- Если мы не укажем, как агрегировать столбец, SQLite выбирает любое произвольное значение из группы.
- Все пингвины в каждой группе имеют один и тот же пол, потому что мы сгруппировали его по этому признаку и получили правильный ответ.
- Значения массы тела имеются в данных, но непредсказуемы.
- Распространенная ошибка
- Другие СУБД этого не делают. Например, PostgreSQL жалуется, что столбец необходимо использовать в функции агрегации.


#### Упражнения

1. Объясните, почему в результатах предыдущего запроса перед строками для самок и самцов пингвинов имеется пустая строка.
2. Напишите запрос, который показывает каждую уникальную массу тела в наборе данных о пингвинах и количество пингвинов, которые весят столько же.

### Сортировка и пагинация агрегированных значений

Найдем среднюю массу тела пингвинов каждого вида. ([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/0c7390c3db139c74fdd89b671302819d/))

```sql
select
    species,
    avg(body_mass_g) as average_body_mass
from penguins
group by species;
```
```
| species   | average_body_mass |
|-----------|-------------------|
| Adelie    | 3700.6622516556   |
| Chinstrap | 3733.0882352941   |
| Gentoo    | 5076.0162601626   |
```

Теперь найдем вид пингвинов с самой большой средней массой тела. Для этого отсортируем результаты по убыванию средней массы тела и ограничим вывод одной первой строкой. ([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/c037348bf459a520f4cf956d088e6f9d/))

```sql
select
    species,
    avg(body_mass_g) as average_body_mass
from penguins
group by species
order by average_body_mass desc
limit 1;
```
```
|---------|-------------------|
| species | average_body_mass |
|---------|-------------------|
| Gentoo  | 5076.0162601626   |
```

- `order by` может быть использован для сортировки результатов агрегации.
- `limit` ограничивает количество строк в результирующем (агрегированном) наборе данных.

#### Упражнения

1. [Найдите остров с минимальной суммарной массой проживающих на нем пингвинов](https://sqltest.online/ru/question/sqlite/light-weight-penguins-island).
2. [Найдите остров с макимальным количеством пингвинов](https://sqltest.online/ru/question/sqlite/crowd-penguins-island).

### Фильтрация агрегированных значений

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/d2a2ad0c36bc566830a0e7a5e0a9065a/))

```sql
select
    sex,
    avg(body_mass_g) as average_mass_g
from penguins
group by sex
having average_mass_g > 4000.0;
```
```
| sex    |  average_mass_g  |
|--------|------------------|
| [null] | 4005.55555555556 |
| MALE   | 4545.68452380952 |
```

- Используйте `having` для фильтрации агрегированных значений вместо `where`.
- Команда `having` пишется сразу после `group by`.

#### Упражнения

1. Найдите острова со средней длиной плавника проживающих на них пингвинов меньше 200 милиметров.


### Читаемый вывод

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/0533124bddd2a3ce1007cb55123ace29/))

```sql
select
    sex,
    round(avg(body_mass_g), 1) as average_mass_g
from penguins
group by sex
having average_mass_g > 4000.0;
```
```
| sex    | average_mass_g |
|--------|----------------|
| [null] | 4005.6         |
| MALE   | 4545.7         |
```

- Используйте `round(значение, количество десятичных знаков)` для округления числа.

###  Фильтрация агрегируемых данных

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/b57970c1f981d1af69e177f418e20e30/))

```sql
select
    sex,
    round(
        avg(body_mass_g) filter (where body_mass_g < 4000.0),
        1
    ) as average_mass_g
from penguins
group by sex;
```
```
|  sex   | average_mass_g |
|--------|----------------|
| [null] | 3362.5         |
| FEMALE | 3417.3         |
| MALE   | 3729.6         |
```

- Условие фильтрации применяется к входным данным агрегирующей функции.
> [!WARNING]
> Не все СУБД поддерживают такой синтаксис!


#### Упражнения

1. Напишите запрос, который использует фильтр для одновременного расчета средней массы тела тяжелых пингвинов (весом более 4500 граммов) и легких пингвинов (весом менее 3500 граммов). Можно ли это сделать, используя `where` вместо `filter`?

### Прверка знаний


<img src="./assets/core_aggregate_concept_map.svg" alt="Описание" style="max-width:100%; height:auto;">

## Cоединение таблиц (join)

<img src="./assets/join.svg" alt="Объединение таблиц" style="max-width:100%; height:auto;">

- Команда `join` объединяет информацию из двух таблиц.
- Резульаьтат - новая таблица, содержащая все столбцы из обеих таблиц.
- Результат может быть соедиён с другими таблицами или использован для агрегации.
- Количество строк в результирующей таблице зависит от типа соединения.

### Перекрестное соединение (cross join)

```sql
select *
from work 
cross join job;
```
```
| person   | job        | name       | billable |
|----------|------------|------------|----------|
| Иван     | Калибровка | Калибровка | 1.5      |
| Иван     | Калибровка | Очистка    | 0.5      |
| Иван     | Очистка    | Калибровка | 1.5      |
| Иван     | Очистка    | Очистка    | 0.5      |
| Иван     | Сортировка | Калибровка | 1.5      |
| Иван     | Сортировка | Очистка    | 0.5      |
| Евгений  | Очистка    | Калибровка | 1.5      |
| Евгений  | Очистка    | Очистка    | 0.5      |
| Евгений  | Сортировка | Калибровка | 1.5      |
| Евгений  | Сортировка | Очистка    | 0.5      |
| Вячеслав | Сортировка | Калибровка | 1.5      |
| Вячеслав | Сортировка | Очистка    | 0.5      |
```

- `cross join` создает перекрестное (или декартово) произведение - все комбинации строк из каждой таблицы.
- Количество строк в результате равно произведению количества строк в каждой из таблиц (m * n). 
- Если одна из таблиц пуста то и результат будет пуст.

В данном случае результат не особенно полезен: значения задания и имени не совпадают, то есть в объединенных данных есть записи, части которых не связаны друг с другом.
*Но это не значит что `cross join` бесполезен всегда. Есть ситуации когда он единственное решение*

### Внутреннее соединение (inner join)

```sql
select *
from work 
inner join job
    on work.job = job.name;
```
```
| person  | job        | name       | billable |
|---------|------------|------------|----------|
| Иван    | Калибровка | Калибровка | 1.5      |
| Иван    | Очистка    | Очистка    | 0.5      |
| Евгений | Очистка    | Очистка    | 0.5      |
```

- Используйте обозначение `table.column` для указания столбцов.
- Столбец может иметь то же имя, что и таблица.
- Используйте `on` чтобы указать условие соединения таблиц.

#### Упражнение

1. Повторно запустите запрос, показанный выше, используя где job = name вместо полной записи table.name. Сокращенная форма легче или труднее читаться и с большей или меньшей вероятностью приведет к ошибкам?

### Агрегирование объединенных данных

```sql
select
    work.person,
    sum(job.billable) as pay
from work 
inner join job
    on work.job = job.name
group by work.person;
```
```
| person  | pay |
|---------|-----|
| Иван    | 2.0 |
| Евгений | 0.5 |
```

- Этот пример объединяет идеи, которые мы видели раньше.
- Но Вячеслав отсутствует в результирующей таблице. В таблице должностей нет записей с именем Вячеслав, поэтому нет записей, которые нужно группировать и суммировать.

### Левое соединение (left join)

```sql
select *
from work 
left join job
    on work.job = job.name;
```
```
| person   | job        | name       | billable |
|----------|------------|------------|----------|
| Иван     | Калибровка | Калибровка | 1.5      |
| Иван     | Очистка    | Очистка    | 0.5      |
| Иван     | Сортировка | [null]     | [null]   |
| Евгений  | Очистка    | Очистка    | 0.5      |
| Евгений  | Сортировка | [null]     | [null]   |
| Вячеслав | Сортировка | [null]     | [null]   |
```

- Левое внешнее соединение сохраняет все строки из левой таблицы.
- Заполняет недостающие значения из правой таблицы нулевым значением

### Агрегированое левое соединение

```sql
select
    work.person,
    sum(job.billable) as pay
from work 
left join job
    on work.job = job.name
group by work.person;
```
```
| person   | pay    |
|----------|--------|
| Иван     | 2.0    |
| Евгений  | 0.5    |
| Вячеслав | [null] |
```

- Так лучше, но нам бы хотелось видеть 0, а не `null`.

### Объединение значений

```sql
select
    work.person,
    coalesce(sum(job.billable), 0.0) as pay
from work 
left join job
    on work.job = job.name
group by work.person;
```
```
| person   | pay |
|----------|-----|
| Иван     | 2.0 |
| Евгений  | 0.5 |
| Вячеслав | 0.0 |
```

- coalesce(val1, val2, …) возвращает первое непустое (не `null`) значение

### Полное внешнее соединение (full outer join)

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/e7704a20a449ccf988505bffc80bb27f/))

- Полное внешнее соединение (`full outer join`) — это объединение левого внешнего соединения (`left outer join`) и правого внешнего соединения (`right outer join`).
- Почти то же самое, что и перекрестное соединение (`cross join`), но учтите, в случае если одна из таблиц пуста полное внешнее соединение приведет к пустому (`null`) результату.

```sql
create table size (
    s text not null
);
insert into size values ('small'), ('large');

create table weight (
    w text not null
);

select * 
from size 
full outer join weight;
```
```
| s     | w      |
|-------|--------|
| small | [null] |
| large | [null] |

```

#### Упражнение

1. Найдите наименьшее время, которое каждый человек потратил на любую работу. Ваши выходные данные должны показать, что Иван и Евгений потратили на какую-то работу по 0,5 часа каждый. Можете ли вы найти способ показать название задания, используя SQL, который вы видели до сих пор?

### Самосоединение (self join)

```sql
with person as (
    select
        ident,
        personal || ' ' || family as name
    from staff
)
select
    left_person.name,
    right_person.name
from person as left_person 
inner join person as right_person
limit 10;
```
```
|     name     |       name       |
|--------------|------------------|
| Kartik Gupta | Kartik Gupta     |
| Kartik Gupta | Divit Dhaliwal   |
| Kartik Gupta | Indrans Sridhar  |
| Kartik Gupta | Pranay Khanna    |
| Kartik Gupta | Riaan Dua        |
| Kartik Gupta | Vedika Rout      |
| Kartik Gupta | Abram Chokshi    |
| Kartik Gupta | Romil Kapoor     |
| Kartik Gupta | Ishaan Ramaswamy |
| Kartik Gupta | Nitya Lal        |
```

1. Соединение таблицы с самой собой
  - Используйте as для создания псевдонимов для копий таблиц, чтобы различать их.
  - Ничего особенного в именах слева и справа.
2. Получить все пары `n^2` , включая человека с самим собой. 

### Проверка знаний

<img src="./assets/core_join_concept_map.svg" alt="Описание" style="max-width:100%; height:auto;">

## Операции над множествами (union, intersect, except)

Команды `union`, `intersect` и `except` позволяют объединять результаты запросов. Результаты должны иметь одинаковое количество столбцов и типы данных. В результате получается один набор данных.

### Объединение результатов запросов (union)

(выполнить union онлайн](https://sqlize.online/sql/sqlite3_data/f819e542b5894bf961e6d97cd2e2ae8c/))

```sql
select
    species, island
from little_penguins
union 
select
    species, island
from penguins;
```

- `union` объединяет результаты двух запросов в один.
- Результаты должны иметь одинаковое количество столбцов и типы данных.
- `union` удаляет дубликаты строк.
- `union all` сохраняет дубликаты строк.

#### Упражнения
1. Замените `union` на `union all` в предыдущем запросе. Как это повлияет на результат?

### Пересечение результатов запросов (intersect)

Найдём виды и острова которые встречаются в обеих таблицах.

(выполнить intersect онлайн](https://sqlize.online/sql/sqlite3_data/dc824423c28c625de77475434205cf94/))

```sql
select
    species, island
from little_penguins
intersect
select
    species, island
from penguins;
```
- `intersect` возвращает только строки, которые присутствуют в обоих результатах запросов.

### Разность результатов запросов (except)

Найдём виды и острова из таблицы `penguins`, которые не встречаются в таблице `little_penguins`.

(выполнить except онлайн](https://sqlize.online/sql/sqlite3_data/2925a5df3b39fb8e4151385d08786927/))

```sql
select
    species, island
from penguins
except
select
    species, island
from little_penguins;
```
- `except` возвращает только строки, которые присутствуют в первом результате запроса, но отсутствуют во втором.

#### Упражнения
1. [Найдите виды пингвинов, которые встречаются на всех островах](https://sqltest.online/ru/question/sqlite/penguins-species-on-all-islands).
